NOIP 08 b 线性数据结构，STL顺序容器和容器适配器（未完成）  
======

|Author|杜博识Dubos|
|---|---|
|E-mail|dubos@foxmail.com|

本文是[NOIP 08 a 普及组数据结构和STL容器](/NOIP%20Junior/NOIP%2008%20a%20数据结构普及组.md)正文的一部分。  

我们已经知道数据结构可以按照逻辑分为集合、线性、树形、图状四类，也可以按存储分为顺序、链式两类。这一节我们学习几种线性数据结构，他们的共同点是从逻辑上讲，在数据元素的非空有限集中：  
* 存在唯一一个“**第一个first数据元素**”；
* 存在唯一一个“**最后一个last数据元素**”；
* 每个数据元素（first数据元素可以例外）只有一个**直接前驱immediate predecessor**；
* 每个数据元素（last数据元素可以例外）只有一个**直接后继immediate successor**。  

他们的不同点是：
* 其中有的属于**顺序存储**：逻辑上相邻的数据在硬件（例如内存）上占据的物理空间也相邻，**寻秩访问（call-by-rank）**；
* 另外一些属于**链式存储**：逻辑上相邻的数据在硬件（例如内存）上占据的物理空间不一定相邻，**循链访问（call-by-link）**。  

我们学习每种数据结构都是先了解其**特征**，然后学习其实现**原理**（用已有C++编程实现其中一些特征），最后学习如何直接使用相应的**STL容器**。下文较长，目录为：  
* [数组](#数组array)
* [顺序表](#顺序表sequence-list)
* [](#)
* [](#)
* [](#)

------  
## 数组array
之前讲过，现在就不重复了。数组是一种**线性、顺序存储的数据结构（即顺序表）**，顺序表的实现也是通过数组。  

## 顺序表sequence list  
* **特征**：
	* 顺序表从逻辑来讲是**线性**数据结构，从存储来讲是**顺序**数据结构。它用一组地址连续的存储单元（数组）依次存储数据元素，逻辑上相邻数据元素的存储位置也相邻，如下图：  
	![](/diagrams/NOIP%2008%20b%20顺序表1.jpg)
	* 访问：**寻秩访问（call-by-rank）** 是指，如果想要知道某个特定数据元素的存储位置或者访问某个元素，只需确定顺序表的起始位置和这个特定数据元素的**秩（rank，也就是序号）**，即可按照上图中的推导方法找到这个特定数据元素的存储位置。数组是具备寻秩访问的特性，所以通常我们的都**用数组来实现顺序表**。数组的元素序号从0开始，而我们一般从第1位（而非第0位元素）开始存储数据元素，这是为了方便与日常编号习惯保持一致；  
	* 插入：在长度为n的顺序表中第i位元素**之前**前插入新元素new，则结果应该是一个长度为n+1的新顺序表，原a<sub>i</sub>被重新赋值为new，原a<sub>i</sub>至a<sub>n</sub>（共n-i+1个）元素的依次向后移动1位，变成新a<sub>i+1</sub>至a<sub>n+1</sub>元素。假设在任何位置前插入新元素的概率相等，则插入导致的移动次数平均为  
	![](/diagrams/NOIP%2008%20b%20顺序表2.gif)  
	所以**顺序表插入操作的时间复杂度为O(n)** ；
	* 删除：在长度为n的顺序表中删除第i位元素，则结果应该是一个长度为n-1的新顺序表，原a<sub>i</sub>元素被删掉，原a<sub>i+1</sub>至a<sub>n</sub>（共n-i个）元素的依次向前移动1位，变成新a<sub>i</sub>至a<sub>n-1</sub>元素。假设在任何位置删除元素的概率相等，则删除导致的移动次数平均为  
	![](/diagrams/NOIP%2008%20b%20顺序表3.gif)  
	所以**顺序表删除操作的时间复杂度为O(n)** ；

* **原理**：我们通过[例1：oj.noi.cn 1109 《维护序列》](https://github.com/Duboshi/OJ-solutions/blob/master/oj.noi.cn/1109%20%E7%BB%B4%E6%8A%A4%E5%BA%8F%E5%88%97.md)实现顺序表的访问、插入和删除。  
	
* **容器**：直接用数组  

## 向量（或称动态数组）vector  
* 《基》P234-235  

* **特征**：向量也是一种顺序表，但相对于数组，向量的长度可变，所以向量也被称为“动态数组”，这个特征使得向量在实际中比数组更实用。虽然向量是用数组实现的，但实际使用时只需要用STL容器vector及其库函数即可，具体库函数下面会介绍。  

* **原理**：访问、插入、删除的原理跟顺序表的一样，需要另外说明的是向量改变长度的原理。数组所占物理空间的容量不能调整，这称为“静态空间管理策略”。而向量不同，每当对向量插入一个元素时，如果实现向量的数组还有可用空间，那么操作正常进行；一旦可用空间耗尽（将会导致上溢overflow），就另行申请一个长度更大（是原数组长度的二倍）的数组，并将原来实现向量的数组复制到新数组，而原数组所占的空间被释放并归还给操作系统，这是**向量的扩容原理**。反过来，每当向量元素被删除，虽然一定不会发生上溢，但是如果向量中剩下的元素太少，实现向量的数组所占大部分空间会被浪费（这种情况叫下溢underflow），所以就要检查向量实际长度与数组所占空间的比值（这个比值叫做装填银子load factor），如果比值低于某个值（例如25%、10%等等），就把一部分多于空间归还给操作系统，这是**向量的缩容原理**。向量的扩容、缩容原理体现了** “动态空间管理策略” **。  

* **容器**：  
	* 我们通过[例2：UVa 101 The Blocks Problem](https://github.com/Duboshi/OJ-solutions/blob/master/UVa/UVa%20101%20The%20Blocks%20Problem.md)应用vector容器及其部分库函数。  

## 链表list
* r《基》P130-135 
* 《入》P143-148，但是这两本书都没有用STL list的例题
```cpp
#include<iostream>

int main() 
{
	return 0;
}
```

## 队列queue
* r《基》P138-141，P233例9.3
* 《入》P117-119，例5-6 
```cpp
#include<iostream>

int main() 
{
	return 0;
}
```

## 双端队列deque
* 《入》P139例6-1
```cpp
#include<iostream>

int main() 
{
	return 0;
}
```

## 优先队列priority_queue
* 《入》P119-120，例5-7 
```cpp
#include<iostream>

int main() 
{
	return 0;
}
```

## 栈stack
* 《入》P115-117
```cpp
#include<iostream>

int main() 
{
	return 0;
}
```

	
###### 参考资料  

> 《CCF中学生程序设计基础篇》第6和9章；  
> 《算法竞赛入门经典》第5.2、6.1、6.2节；  
> 《新标准C++程序设计教程》第19章；  
> 《数据结构（C语言）》（严蔚敏，吴伟民）第1-6章；  
> 《数据结构（C++语言）》（邓俊辉）第1-6章；  
> Competitive Programming 3 第2章；  
> Introduction to Algorithms 第1、第10章；  
> C++ Primer 第9、11章；  
> The C++ standard library 第6-12章。  
