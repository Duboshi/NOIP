/*	@author 杜博识Dubos

NOIP 03.2 二维数组
	以《CCF入门篇》第5章5.5节；
	以《一本通》第一部分第五章第二节为辅；
	以《入门经典》第3章为参考；
*/

#include <cstdio>
#include <iostream>
using namespace std;

int main()
{
	int r,c;

	printf("例1：二维数组\n");
		/*（《入门篇》P233例5.24）
		5名学生成绩单如下：
		学号 语文 数学 英语 物理 化学 生物
		   1  105  140  109   91   90  100
		   2  115  141  119   92   91  100
		   3  125  142  129   93   92  100
		   4  135  143  139   94   93  100
		   5  145  144  149   95   94  100
		我们可以用二维数组储存这些数据，并在成绩单增加最后一列算出每位同学的总分，
		再增加最后一行算出各科以及总分的平均分。
	
		【二维数组】（《CCF入门篇》p235，《一本通》p90）：
		1. 当一个数组中的每个元素都是一个数组时，这个数组便是数组的数组，即
			二维数组；
		2. 建立二维数组的方法是：
			base_type name [row][column]
			例如
			double mat [5][7];
			这个二维数组有5行、7列，每个元素都是实数，
			或者说由5个一维数组组成，其中每个一维数组都包含7个实数；
		3. 以此类推，还可以建立多维数组，处理二位数组和多维数组也需要防止越界；
		4. 二维数组的初始化：见下面例子
		*/
		double mat [5][7] = {
			{1, 105, 140, 109, 91, 90, 100},
			{2, 115, 141, 119, 92, 91, 100},
			{3, 125, 142, 129, 93, 92, 100},
			{4, 135, 143, 139, 94, 93, 100},
			{5, 145, 144, 149, 95, 94, 100}
		};
	
		//输出成绩表矩阵，只保留整数位
		for (r=0; r<5; r++) {
			for (c=0; c<7; c++) {
				printf("%6.0f", mat[r][c]);
			}
			printf("\n");
		}
		printf("\n");

		//建立一个新数组，增加一列总分和一行平均分
		double mat2 [6][8] = {}; //将每个元素初始化赋值为0
		for (r=0; r<5; r++) {
			mat2[r][0] = mat[r][0];
			for (c=1; c<7; c++) {
				mat2[r][c] = mat[r][c];
				mat2[r][7] += mat2[r][c];
			}
		}
		for (c=1; c<8; c++) {
			for (r=0; r<5; r++)
				mat2[5][c] += mat2[r][c];
			mat2[5][c] /= 5;
		}
	
		//输出新成绩表矩阵，学号不保留小数点，其他保留小数点后一位；
		for (r=0; r<6; r++) {
			printf("%6.0f", mat2[r][0]);
			for (c=1; c<8; c++) {
				printf("%6.1f", mat2[r][c]);
			}
			printf("\n");
		}
	printf("\n");

	printf("例2：二维数组的应用 - 杨辉三角形 Pascal's Triangle\n");
		/*《入门篇》p236例5.25，《一本通》p93例5.11
			输出杨辉三角形前10行，其第r行有r个数，每行的首尾数均为1，
			其余非首尾数满足pas[r][c] = pas[r-1][c-1] + pas[r-1][c]
		*/
		int pas[10][10];
		pas[0][0] = 1;
	
		for(r=1; r<10; r++) {
			pas[r][0] = 1;
			pas[r][r] = 1;
			for (c=1; c<r; c++)
				pas[r][c] = pas[r-1][c-1] + pas[r-1][c];
		}
	
		for (r=0; r<10; r++) {
			for (c=0; c<=r; c++) {
				printf("%8d ", pas[r][c]);
			}
			printf("\n");
		}
	printf("\n");

	printf("例3：二维数组的应用 - 蛇形填数\n");
		/*（《CCF入门篇》p238例5.26，《一本通》p94例5.13）
		输入样例：整数n
			4 
		输出样例：n*n（n<25）方阵，并从左上角开始，逆时针从外周以此填入1, 2, 3...
		等数字 
		10 11 12  1
		 9 16 13  2
		 8 15 14  3
		 7  6  5  4
		*/
		int n;
		cin>>n;
		int sna [n][n] = {};
	
		r=0;
		c=n-1;
		int num = 1;
		sna[r][c] = num;
	
		while (num<n*n) {
			while (r+1<n && sna[r+1][c]==0)
				sna[++r][c] = ++num; //向下
			while (c-1>=0 && sna[r][c-1]==0)
				sna[r][--c] = ++num; //向左
			while (r-1>=0 && sna[r-1][c]==0)
				sna[--r][c] = ++num; //向上
			while (c+1<n && sna[r][c+1]==0)
				sna[r][++c] = ++num; //向右
		}
	
		for (r=0; r<n; r++) {
			for (c=0; c<n; c++)
				printf("%6d", sna[r][c]);
			printf("\n");
		}
	printf("\n");

	printf("例4：二维数组的应用 - 扫雷游戏\n");
		/*（《CCF入门篇》p258习题4，http://noi.openjudge.cn/ch0108/14/）
		每个扫雷游戏都有两个图：
			一个是r行c列的雷区分布图，每个格子用*表示雷，用#表示没有雷；
			另一个则是r行c列的提示信息图，后者是根据前者计算出来的：
				每个格子里面的数字都代表其周围八个（上、下、左、右、左上、
				左下、右上、右下）位置的雷数，如果刚好有雷则为*而不是数字；
		输入样例：第一行是行数r和列数c（数字之间有空格），接下来是雷区分布图
			（字符之间无间隔）
			3 3
			*##
			###
			#*#
		输出样例：提示信息图（字符之间无间隔）
			 * 1 0
			 2 2 1
			 1 * 1
		*/
		int m;
		cin>>m>>n;
	
		char mine1 [m+2][n+2];//为了方便，我们把周围留出一圈空白的行和列 
		for (r=1; r<m+1; r++)
			for (c=1; c<n+1; c++)
				cin>>mine1[r][c];
	
		int mine2 [m+2][n+2] = {};
		for (r=1; r<m+1; r++)
			for (c=1; c<n+1; c++) {
				if (mine1[r][c]=='*')
					mine2[r][c]=1;
			}
	
		for (r=1; r<m+1; r++) {
			for (c=1; c<n+1; c++) {
				if (mine2[r][c]==1)
					printf("%c",'*');
				else
					printf("%d",mine2[r-1][c] + mine2[r+1][c] +
					       mine2[r][c-1] + mine2[r][c+1] + mine2[r-1][c-1] +
					       mine2[r+1][c-1] + mine2[r-1][c+1] + mine2[r+1][c+1]);
			}
			printf("\n");
		}
	printf("\n");

	printf("例5：二维数组的应用 - 过河卒\n");
		/*中国象棋中的小卒过河之后面对半个棋盘(有5行9列)，假设他过河后的起点
		坐标为(0,0)，即行序号为0、列序号为0，且他只能向前（行序号+1）或者向右走
		（列序号+1），不可以向后或者向左走。
		 
		则这名小卒从(0, 0)走到(m, n)的路径一共有多少条？
		答案：
		从m+n个中选m个（或n个）的组合数。因为一共需要走m+n步，其中m步向前，n步
		向右，所以要从m+n步中选出m步用于向上走，当然选出n步用于向右走的结果也
		一样。
		 
		假设最初我们没有想到用组合的方法即可简单解决这个问题，那么我们可以用
		计算机模拟这个过程：
		1. 建立二维数组int path [m+1][n+1]，其每个点path[r][c]用于表示从(0, 0)
			走到(r, c)的路径数量；
		2. 如果目的地在第0行或者第0列，则路径为1：path[r][0] = path[0][c] = 1;
		3. 如果目的地(r, c)不在第0行或第0列上，则有此等式成立：
			path[r][c] = path[r-1][c] + path[r][c-1];
		这就变成了一个递推问题。
		
		输入：目的地横纵坐标m和n，用空格间隔
			4 8 
		输出：路径数量
			495 
		*/
		cin>>m>>n;
		
		int path [m+1][n+1] = {};
		for (r=0; r<m+1; r++)
			path[r][0] = 1;
		for (c=0; c<n+1; c++)
			path[0][c] = 1;
		for (r=1; r<m+1; r++)
			for (c=1; c<n+1; c++)
				path[r][c] = path[r-1][c] + path[r][c-1];
		
//		printf("Print path.");
//		for (r=0; r<m+1; r++)
//		{
//			for (c=0; c<n+1; c++)
//				printf("%4d", path[r][c]);
//			printf("\n");
//		}

		printf("%d\n", path[m][n]);
	printf("\n");
	
	printf("例6：二维数组的应用 - 过河卒与敌马\n");
		/*（《CCF入门篇》p250例5.31） 
		还是刚才那名过河卒，其移动规则不变， 敌方在坐标(x, y)处有一马，x<m, y<n, 
		马的移动规则是：对于每步的行序号改变值dx和列序号改变值dy，满足|dx*dy|=2。
		假设除非一步即可吃掉小卒或者下一步将被小卒吃掉，否则敌方的马不会移动。
		那么：

		1. 半个棋盘中最多有几个点是小卒不能经过的？
			答案：
			9个，不是8个，因为马原来站的地方也算，这9个点暂称为“敌马控制点”。 
		2. 过河卒要从(0，0)走到目的地(m, n)共有几种路径？
			答案：
			本题与上题最重要的区别在于本题中“敌马控制点”处path[r][c]=0，并由此
			导致控制点后续的路径数受到影响。

		输入样例：（四个整数，分别为m, n, x, y，即目的地和敌马的坐标）
			6 6 3 2
		输出样例：（路径数量）
		 	17 
		*/
		int x, y;
		cin>>m>>n>>x>>y;
		
		int path2 [m+1][n+1] = {};//用于记录走到每个点的路径 
		int check [m+1][n+1] = {};//用于标记敌马控制点
		
		int dx [] = {1, 1, 2, 2, -1, -1, -2, -2};
		int dy [] = {2, -2, 1, -1, 2, -2, 1, -1};
		check[x][y] = 1;
		for (int i=0; i<8; i++)
			if (x+dx[i]>=0 && x+dx[i]<=m && y+dy[i]>=0 && y+dy[i]<=n)
				check[x+dx[i]][y+dy[i]] = 1;
		
//		printf("Print check.\n");
//		for (r=0; r<m+1; r++)
//		{
//			for (c=0; c<n+1; c++)
//				printf("%4d", check[r][c]);
//			printf("\n");
//		}
//		printf("\n");
		
		//给path第0行和第0列赋值，控制点之前为1，控制点及其之后为0 
		r = 0;
		while (check[r][0]==0 && r<n+1)
			path2[r++][0] = 1;
		c = 0;
		while (check[0][c]==0 && c<n+1)
			path2[0][c++] = 1;
	
		//给path其他元素赋值，控制点的值为0，其他按照递推公式 
		for (r=1; r<m+1; r++)
			for (c=1; c<n+1; c++)
			{
				if (check[r][c] == 1)
					path2[r][c] = 0;
				else
					path2[r][c] = path2[r-1][c] + path2[r][c-1];
			}
		
//		printf("Print path2.\n");
//		for (r=0; r<m+1; r++)
//		{
//			for (c=0; c<n+1; c++)
//				printf("%4d", path2[r][c]);
//			printf("\n");
//		}
//		printf("\n");
		
		printf("%d", path2[m][n]);
	printf("\n");
}

/*	作业：
		1.8编程基础之多维数组（25题） http://noi.openjudge.cn/ch0108/
*/
